package handshake

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/winterrdog/lean-bit-torrent-client/common"
)

func TestNew(t *testing.T) {
	infoHash := common.Sha1Hash{
		0x13, 0x9a, 0x26, 0x9d, 0x57, 0x6d, 0x8c, 0x6c, 0x2c, 0x7b,
		0x7b, 0x0b, 0x7f, 0x3d, 0x5d, 0x5c, 0x7d, 0x5d, 0x5a, 0x5d,
	}
	peerId := common.Sha1Hash{
		0x13, 0x9a, 0x26, 0x9d, 0x57, 0x6d, 0x8c, 0x63, 0x2c, 0x72,
		0x7e, 0x0b, 0x7f, 0x3d, 0x52, 0x5c, 0x7d, 0x5d, 0x5a, 0x5d,
	}
	hs := New(&infoHash, &peerId)

	expected := &Handshake{
		Pstr:     "BitTorrent protocol",
		InfoHash: infoHash,
		PeerId:   peerId,
	}

	assert.Equal(t, expected, hs)
}

func TestSerialize(t *testing.T) {
	/*
		test cases
		1. serialize a valid message
	*/

	// 1. serialize a valid message
	var infoHash = common.Sha1Hash{
		0x13, 0x9a, 0x26, 0x9d, 0x57, 0x6d, 0x8c, 0x6c, 0x2c, 0x7b,
		0x7b, 0x0b, 0x7f, 0x3d, 0x5d, 0x5c, 0x7d, 0x5d, 0x5a, 0x5d,
	}
	var peerId = common.Sha1Hash{
		0x13, 0x9a, 0x26, 0x9d, 0x57, 0x6d, 0x8c, 0x63, 0x2c, 0x72,
		0x7e, 0x0b, 0x7f, 0x3d, 0x52, 0x5c, 0x7d, 0x5d, 0x5a, 0x5d,
	}
	var hs = New(&infoHash, &peerId)

	var expected = []byte{
		19,                                                                                        // len of protocol ID
		66, 105, 116, 84, 111, 114, 114, 101, 110, 116, 32, 112, 114, 111, 116, 111, 99, 111, 108, // protocol ID
		0, 0, 0, 0, 0, 0, 0, 0, // reserved bytes
		0x13, 0x9a, 0x26, 0x9d, 0x57, 0x6d, 0x8c, 0x6c, 0x2c, 0x7b, 0x7b, 0x0b, 0x7f, 0x3d, 0x5d, 0x5c, 0x7d, 0x5d, 0x5a, 0x5d, // info hash
		0x13, 0x9a, 0x26, 0x9d, 0x57, 0x6d, 0x8c, 0x63, 0x2c, 0x72, 0x7e, 0x0b, 0x7f, 0x3d, 0x52, 0x5c, 0x7d, 0x5d, 0x5a, 0x5d, // peer id
	}

	assert.Equal(t, expected, hs.Serialize())
}

func TestRead(t *testing.T) {
	/*
		test cases
		1. read a valid message
		2. read a message with protocol ID length 0
		3. read an empty message
		4. read a message with not enough bytes
	*/

	// 1. read a valid message
	var infoHash = common.Sha1Hash{
		0x13, 0x9a, 0x26, 0x9d, 0x57, 0x6d, 0x8c, 0x6c, 0x2c, 0x7b,
		0x7b, 0x0b, 0x7f, 0x3d, 0x5d, 0x5c, 0x7d, 0x5d, 0x5a, 0x5d,
	}
	var peerId = common.Sha1Hash{
		0x13, 0x9a, 0x26, 0x9d, 0x57, 0x6d, 0x8c, 0x63, 0x2c, 0x72,
		0x7e, 0x0b, 0x7f, 0x3d, 0x52, 0x5c, 0x7d, 0x5d, 0x5a, 0x5d,
	}
	var hs = New(&infoHash, &peerId)
	var serialized = hs.Serialize()

	var reader = bytes.NewReader(serialized)
	var hs2, err = Read(reader)
	assert.NoError(t, err)
	assert.Equal(t, hs, hs2)

	// 2. read a message with protocol ID length 0
	serialized[0] = 0
	reader = bytes.NewReader(serialized)

	hs2, err = Read(reader)
	assert.Error(t, err)
	assert.Nil(t, hs2)

	// 3. read an empty message
	serialized = []byte{}
	reader = bytes.NewReader(serialized)

	hs2, err = Read(reader)
	assert.Error(t, err)
	assert.Nil(t, hs2)

	// 4. read a message with not enough bytes
	serialized = []byte{19, 66, 105, 116, 84, 111, 114, 114, 101, 110, 116, 32, 112, 114, 111, 116, 111, 99, 111, 108}
	reader = bytes.NewReader(serialized)

	hs2, err = Read(reader)
	assert.Error(t, err)
	assert.Nil(t, hs2)
}
